‚úÖ Fase 1: Transferencia de archivos/directorios entre nodos
Objetivo:

Permitir que cualquier nodo pueda enviar archivos o directorios a otro nodo.
Tareas:

Dise√±ar el protocolo de comunicaci√≥n entre nodos (TCP/gRPC).

Crear una estructura de identificaci√≥n de nodos (ID + direcci√≥n IP/puerto).

Implementar el env√≠o de archivos entre nodos:

    Fragmentaci√≥n de archivos (como hace BitTorrent) [opcional].

    Checksum para verificar integridad.

    Definir un directorio ra√≠z sincronizable por nodo.

Herramientas/paquetes Go:

    net, net/http, io/ioutil, os

    Para P2P: libp2p, o implementaci√≥n propia con TCP/UDP.

‚úÖ Fase 2: Eliminaci√≥n remota de archivos/directorios
Objetivo:

Permitir que cualquier nodo solicite la eliminaci√≥n de archivos/directorios en cualquier otro nodo.
Tareas:

Crear un esquema de comandos: DELETE <path> FROM <peer_id>.

Asegurar que las eliminaciones se propaguen a todos los nodos activos.

    Registrar operaciones para aplicarlas luego a nodos desconectados.

Consideraciones:

    Puede usarse un log distribuido o un sistema de colas en memoria/archivo para manejar cambios pendientes.

‚úÖ Fase 3: Visualizaci√≥n del sistema de archivos
Objetivo:

Permitir que cada nodo vea la estructura de archivos de los dem√°s.
Tareas:

Implementar una representaci√≥n local del √°rbol de archivos.

Sincronizar estructuras entre nodos (pull o push, cada X tiempo).

    Resolver conflictos (√∫ltima modificaci√≥n, hashes).

Herramientas:

    Podr√≠as usar estructuras como Merkle Trees para representar directorios y detectar cambios.

‚úÖ Fase 4: Interfaz Gr√°fica (GUI)
Objetivo:

Crear una GUI intuitiva para que el usuario realice las operaciones anteriores.
Tareas:

Crear ventanas separadas por nodo.

Mostrar estructura de archivos (tipo explorador).

A√±adir botones para "Transferir" y "Eliminar".

    Sincronizar visualizaciones en tiempo real.

Herramientas:

    Fyne (recomendado para GUI en Go)

    Alternativas: gioui, Walk (Windows), o conexi√≥n con front-end web (e.g. v√≠a WebSockets + frontend en React o similar)

üß† Fundamentos de funcionamiento (BitTorrent-like)

    Cada nodo es servidor y cliente a la vez.

    Usa TCP para conexiones persistentes.

    Los nodos se identifican por un peer ID y un puerto.

    Las operaciones (transferencia, eliminaci√≥n, visualizaci√≥n) se env√≠an como mensajes serializados (tipo JSON o gob).

    Cada nodo mantiene un log de operaciones aplicadas para permitir sincronizaci√≥n tras reconexi√≥n.

    Si un nodo falla, el resto sigue trabajando y mantiene registro de cambios.
