✅ Estado actual del proyecto
🟢 Infraestructura base ya implementada:

    Identidad única de cada peer (peer.id)

    Registro de operaciones (operations.log)

    Formato común de mensajes (Message{} en JSON)

    Comunicación P2P funcional (net.Conn)

    Manejo de mensajes tipo TRANSFER, SYNC

    Comando CLI funcional (send, sync)

🧩 Fase 1: Transferencia de archivos

| Requisito                                              | Estado       | Notas                                                          |
| ------------------------------------------------------ | ------------ | -------------------------------------------------------------- |
| Envío de archivos entre nodos                          | ✅ Completado | Usando JSON con payload binario                                |
| Encabezado con longitud de nombre y tamaño del archivo | ❌ Pendiente  | No es necesario por ahora gracias a JSON, pero mejora robustez |
| Soporte para carpetas (transferencia recursiva)        | ❌ Pendiente  | Ideal usar `filepath.Walk` y enviar ZIP o tarball              |
| Verificación de integridad (hash/checksum)             | ❌ Pendiente  | Puedes calcular hash SHA256 del archivo y verificar al recibir |
| Retrys o colas en caso de error                        | ❌ Pendiente  | Implementar con goroutines o `pending_ops.json`                |
| Reenvío de archivos pendientes tras reconexión         | ⚠️ Parcial   | Podrías extender `RequestSync()` para incluir `TRANSFER`       |

📌 Prioridad recomendada: hash + carpetas primero.

🔥 Fase 2: Eliminación remota de archivos
| Requisito                                | Estado      | Notas                                               |
| ---------------------------------------- | ----------- | --------------------------------------------------- |
| Comando `DELETE <archivo>` desde CLI     | ❌ Pendiente | Aún no está en `main.go`                            |
| Propagación a todos los peers            | 🔄 Parcial  | Ya tienes `BroadcastMessage()`, solo falta `DELETE` |
| Registro de `DELETE` en el log local     | ❌ Pendiente | Se agregará al implementar `handleDelete()`         |
| Reaplicación de `DELETE` tras reconexión | ⚠️ Parcial  | `SYNC` ya existe, solo falta enviar/leer `DELETE`   |

📌 Siguiente paso lógico inmediato: implementar comando delete.

📁 Fase 3: Visualización del sistema de archivos
| Requisito                                            | Estado      | Notas                                                 |
| ---------------------------------------------------- | ----------- | ----------------------------------------------------- |
| Envío de estructura de archivos al resto             | ❌ Pendiente | Puedes usar `filepath.Walk()` y enviar JSON del árbol |
| Sincronización periódica o bajo demanda              | ❌ Pendiente | Puede integrarse en SYNC o como comando nuevo         |
| Mostrar solo carpeta "permitida" (e.g., `/shared/`)  | ❌ Pendiente | Define una ruta base y filtra desde ahí               |
| Resolución de conflictos (última modificación, etc.) | ❌ Pendiente | Requiere mantener metadatos: `mtime`, hashes, etc.    |
📌 Recomendación: definir estructura FileTree y comando list.

🖼 Fase 4: GUI
| Requisito                                    | Estado      | Notas                                |
| -------------------------------------------- | ----------- | ------------------------------------ |
| Interfaz gráfica tipo explorador de archivos | ❌ Pendiente | Nada iniciado aún                    |
| Operaciones por clic (transferir, eliminar)  | ❌ Pendiente | Fyne es una excelente opción para Go |
| Ver estructuras de archivos remotos          | ❌ Pendiente | Se habilita con `list` remoto        |
| Mostrar mensajes de estado / errores         | ❌ Pendiente | Se integra con logs locales          |
📌 Sugerencia: cuando termines TRANSFER, DELETE, y LIST, puedes montar UI encima sin tocar lógica de red.



🟡 Evaluación general
| Categoría              | Estado         |
| ---------------------- | -------------- |
| Infraestructura        | 🟢 Completa    |
| Transferencia básica   | 🟢 Completa    |
| Sincronización         | 🟢 Funcional   |
| Eliminación remota     | 🔶 Parcial     |
| Visualización remota   | 🔴 No iniciada |
| Interfaz gráfica (GUI) | 🔴 No iniciada |

✅ Recomendaciones inmediatas

    Implementar comando delete <archivo>: es la forma más natural de probar BroadcastMessage() y handleDelete.

    Extender SYNC para que también recupere operaciones tipo DELETE (esto ya casi está listo).

    Luego: soporte para carpetas y verificación de integridad.

